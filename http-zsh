#!/usr/bin/env zsh

zmodload zsh/net/tcp

# ztcp -vcf

zparseopts -D -E -F - \
    s=serv_type -static=serv_type \
    h=serv_type -html=serv_type \
    f=serv_type -file=serv_type \
    p:=port_value -port:=port_value || exit 1

port_value_error="Error - pass one port option:\n\t(-p|--port)"

if [[ "${#port_value}" -ne "2" && "${#port_value}" -gt "1" ]]; then
    echo "$port_value_error" && exit
fi

case "${port_value:0:1}" in
-p | --port)
    readonly PORT="${port_value:1:1}"
    ;;
*)
    readonly PORT=1234
    ;;
esac

server_type_error="Error - pass one server type option:\n\tstatic (-s|--static)\n\thtml (-h|--html)"

if [[ "${#serv_type}" != 1 ]]; then
    echo "$server_type_error" && exit
fi

serv_type=${serv_type:0:1}

typeset -A conf=(
    PORT $PORT 
    HOST localhost 
    CHUNK_SIZE 1024
)

typeset -A CONTENT_TYPES=(
    html text/html
    css text/css
    png image/png
    gif image/gif
    jpeg image/jpeg
    jpg image/jpg
    webp image/webp
    js application/javascript
)

echo "port: $conf[PORT]"
echo "host: $conf[HOST]"

typeset -r BR="\r\n"

#######################################
# Open a tcp socket and listen for http requests
# Arguments:
#   status_code
#   status_message
#   bodys
# Outputs:
#   HTTP Response (text/html)
#######################################
http_response() {
    local status_code="$1"
    local status_message="$2"
    local STATUS=" $status_code $status_message$BR"

    local BODY="$3"
    local body_len=$(echo -ne $BODY | wc --chars || echo -ne 0)

    local HEADERS="content-length: $body_len${BR}content-type: text/html$BR$BR"
    if [[ 0 = "$body_len" ]]; then
        HEADERS="$BR"
    fi

    local STATIC_RESP="HTTP/1.1$STATUS$HEADERS$BODY"

    print "$STATIC_RESP"
}

#######################################
# Print a http response with predifined headers
# Arguments:
#   status_code
#   status_message
#   HEADER_CUSTOM
#   BODY
# Outputs:
#   HTTP Response
#######################################
http_response_headers() {
    local status_code="$1"
    local status_message="$2"
    local STATUS=" $status_code $status_message$BR"

    local BODY="$4"
    local body_len=$(echo -ne $BODY | wc --chars || echo -ne 0)

    local HEADER_CUSTOM="$3"
    local HEADER_TYPE="content-type: text/html$BR"
    local HEADER_CONTENT_LEN=$([[ 0 = $body_len ]] && echo "content-length: $body_len${BR}")
    local HEADERS=$([[ "" = $HEADER_CUSTOM ]] && echo "$HEADER_TYPE$HEADER_CONTENT_LEN$BR" || echo "$HEADER_CUSTOM$BR")

    local STATIC_RESP="HTTP/1.1$STATUS$HEADERS$BODY"

    print "$STATIC_RESP"
}

http_response_img() {
    local status_code="$1"
    local status_message="$2"
    local STATUS=" $status_code $status_message$BR"

    local BODY_PATH="$3"
    local CONTENT_TYPE="$(echo "$BODY_PATH" | sd '.*\.(\w+)$' '$1')"
    local BODY=$(cat $BODY_PATH)
    local body_len="$(wc --bytes --total=only $BODY_PATH || echo -ne 0)"

    local HEADERS="accept-ranges: bytes${BR}content-length: $body_len${BR}content-type: image/$CONTENT_TYPE$BR$BR"
    if [[ 0 = "$body_len" ]]; then
        HEADERS="$BR"
    fi

    # local STATIC_RESP="HTTP/1.1$STATUS$HEADERS$BODY"
    local STATIC_RESP="HTTP/1.1$STATUS$HEADERS"

    # echo -ne "$STATIC_RESP"
    print "$STATIC_RESP"
}

#######################################
# Print a http response for differnt content types
# Arguments:
#   status_code
#   status_message
#   BODY_PATH
# Outputs:
#   HTTP Response
#######################################
http_response_neue() {
    local status_code="$1"
    local status_message="$2"
    local STATUS=" $status_code $status_message$BR"

    local BODY_PATH="$3"
    local FILE_EXTENSION="$(echo "$BODY_PATH" | sd '.*\.(\w+)$' '$1')"
    local BINARY="$(file -i $BODY_PATH | rg --quiet binary && echo true || echo false)"
    # local BODY=$(cat $BODY_PATH)

    local body_len=0
    if [[ 'true' = $BINARY ]]; then
        body_len="$(wc --bytes --total=only $BODY_PATH || echo -ne 0)"
    else
        body_len="$(wc --chars --total=only $BODY_PATH || echo -ne 0)"
    fi

    local HEADER_CUSTOM="" # TODO
    local HEADER_TYPE="content-type: $CONTENT_TYPES[$FILE_EXTENSION]$BR"
    local HEADER_CONTENT_LEN="content-length: $body_len$BR"
    local HEADERS="$([[ "" = $HEADER_CUSTOM ]] && echo "accept-ranges: bytes${BR}$HEADER_TYPE$HEADER_CONTENT_LEN$BR" || echo "$HEADER_CUSTOM$BR")"

    local STATIC_RESP="HTTP/1.1$STATUS$HEADERS"

    print "$STATIC_RESP"
}

typeset -r DEFAULT_BODY="<h1>Hello, world!</h1>"
typeset -r DEFAULT_RESPONSE=$(http_response 200 Ok "$DEFAULT_BODY")

typeset -r CHUNK_SIZE=1024

#######################################
# Router HTTP request and respond based on the method and path.
# Only GET get is support all other methods will trigger a 500.
# IF path "/"
#    IF "./index.html" exist return as response body
#    ELSE return a default 200 HTML response body
# ELSE path "*"
#    IF ".(path)index.html" exist return as response body
#    ELSE return 404
# Arguments:
#   route
# Outputs:
#   HTTP Response (text/html)
#######################################
html_router() {
    ROUTE_PATH="$1"

    case "$ROUTE_PATH" in
    *.html)
        if [ -e ".$ROUTE_PATH" ]; then
            http_response 200 Ok "$(bat ".$ROUTE_PATH")"
        else
            http_response 404 "Not found" "<p>Page not found.</p>"
        fi
        ;;
    "/")
        ROUTE_PATH_CHARS="$(echo -n $ROUTE_PATH | wc --chars)"
        if [[ "$ROUTE_PATH_CHARS" > 1 ]]; then
            http_response 404 "Not found" "<p>Page not found.</p>"
        elif [ -e "./index.html" ]; then
            local BODY=$(cat ".${ROUTE_PATH}index.html")
            http_response 200 Ok "$BODY"
        else
            http_response 404 "Not found" "<p>Page not found.</p>"
        fi
        ;;
    *)
        ROUTE_FILE="./$ROUTE_PATH/index.html"
        if [ -e "$ROUTE_FILE" ]; then
            http_response 200 Ok "$(bat "$ROUTE_FILE")"
        else
            http_response 404 "Not found" "<p>Page not found.</p>"
        fi
        ;;
    esac
}

html-handler() {
    local HANDLER_METHOD=$1
    local HANDLER_PATH=$2

    case $HANDLER_METHOD in
    "GET")
        RESP_200=$(html_router "$HANDLER_PATH")
        echo -ne $RESP_200
        ;;
    "HEAD")
        RESP_501=$(http_response 501 "Not Implemented" "")
        echo -ne $RESP_501
        ;;
    *)
        RESP_501=$(http_response 501 "Not Implemented" "<p>Unsupported method ($HANDLER_METHOD)</p>")
        echo -ne $RESP_501
        ;;
    esac
}

file_router() {
    local ROUTE_PATH="$1"
  
    case "$ROUTE_PATH" in
    *.png | *.gif | *.jpeg | *.jpg | *.webp )
        if [ -e ".$ROUTE_PATH" ]; then
            http_response_img 200 Ok ".$ROUTE_PATH"
        else
            http_response 404 "Not found" "<p>Page not found. $ROUTE_PATH</p>"
        fi
        ;;
    *.html)
        if [ -e ".$ROUTE_PATH" ]; then
            http_response 200 Ok "$(bat ".$ROUTE_PATH")" 
        else
            http_response 404 "Not found" "<p>Page not found. $ROUTE_PATH</p>"
        fi
        ;;
    "/")
        ROUTE_PATH_CHARS="$(echo -n $ROUTE_PATH | wc --chars)"
        if [[ "$ROUTE_PATH_CHARS" > 1 ]]; then
            http_response 404 "Not found" "<p>Page not found.</p>"
        elif [ -e "./index.html" ]; then
            local BODY=$(cat ".${ROUTE_PATH}index.html")
            http_response 200 Ok "$BODY"
        else
            http_response 404 "Not found" "<p>Page not found. $ROUTE_PATH</p>"
        fi
        ;;
    *)
        ROUTE_FILE="./$ROUTE_PATH/index.html"
        if [ -e "$ROUTE_FILE" ]; then
            http_response 200 Ok "$(cat "$ROUTE_FILE")"
        else
            http_response 404 "Not found" "<p>Page not found. $ROUTE_PATH</p>"
        fi
        ;;
    esac
}

file-handler() {
    local HANDLER_METHOD=$1
    local HANDLER_PATH=$2

    case $HANDLER_METHOD in
    "GET")
        # RESP_200=$(file_router "$HANDLER_PATH")
        # echo -ne $RESP_200
        print "$(file_router "$HANDLER_PATH")"
        ;;
    "HEAD")
        RESP_501=$(http_response 501 "Not Implemented" "")
        print $RESP_501
        ;;
    *)
        RESP_501=$(http_response 501 "Not Implemented" "<p>Unsupported method ($HANDLER_METHOD)</p>")
        print $RESP_501
        ;;
    esac
}

http-listen() {
    local PORT=$conf[PORT]
    ztcp -v -l $PORT && echo "listening on $PORT...\n"
    listenfd=$REPLY

    while true; do

        ztcp -v -a $listenfd && echo "\n\naccept request...\n"
        fd=$REPLY

        typeset req_method req_path req_version
        read -r -u $fd req_method req_path req_version || echo noheader

        echo "method:$req_method\npath: $req_path\nversion: $req_version\n\n"

        typeset -A req_headers
        typeset header_key header_value

        while read -r -u $fd header_key header_value && [[ $header_key != $'\r' ]] && [[ -n $header_value ]]; do
            header_key=$(tr -d ':' <<< "$header_key")
            req_headers[$header_key]=$(tr -d '\r' <<< $header_value)
        done

        typeset req_headers_json="\"headers\": {"
        for key in "${(@k)req_headers}"; do
            req_headers_json+="\"$key\":\"${req_headers[$key]}\","
        done
        req_headers_json+=$(sd '(.*),' '$1}' <<< "$req_headers_json")
        echo $req_headers_json

        if [[ "${req_headers[Content-Length]}" > 0 ]]; then
            typeset req_body=""

            case $req_method in
                ('GET'| 'HEAD'| 'TRACE')
                    # do nothing
                    unset  req_body req_body_json
                ;;
                (*)
                    while true; do
                        chunk=$(timeout 0.01 dd bs=$CHUNK_SIZE count=1 <&$fd 2>/dev/null)

                        if [[ $? -ne 0 || -z "$chunk" ]]; then
                            break
                        fi

                        req_body+=$chunk
                    done

                    typeset req_body_json="\"body\":\"$req_body\""
                    echo $req_body_json
                ;;
            esac
        fi


        case "$serv_type" in
        -s | --static)
            echo $DEFAULT_RESPONSE >&$fd
            ;;
        -h | --html)
            HTML_RESPONSE=$(html-handler "$req_method" "$req_path")
            echo $HTML_RESPONSE >&$fd
            ;;
        -f | --file)
            HTML_RESPONSE=$(file-handler "$req_method" "$req_path")
            print >&$fd $HTML_RESPONSE && test -f ".$req_path" && bat >&$fd ".$req_path"
            ;;
        esac

        unset req_headers req_headers_json req_body req_body_json
        unset req_method req_path req_version
        unset header_key header_value

        ztcp -v -c $fd && echo "\n\nclose...\n"
    done

    ztcp -vc $listenfd
    ztcp -vc $fd
}

http-listen
